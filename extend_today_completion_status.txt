Goal: represent schedule block status (“missed”, “in progress”, “upcoming”, “completed”) alongside the current time-based colors, and add a `did` command to log completions.

Data model updates
------------------
- Continue using `User/Schedules/today_schedule.yml` for the planned blocks and `User/Schedules/completions/<YYYY-MM-DD>.yml` for completion metadata.
- Extend the per-day completion file to capture:
  * `name`: block/template/item name (string).
  * `scheduled_start` / `scheduled_end`: optional timestamps for the block window.
  * `actual_start` / `actual_end`: optional timestamps supplied via the `did` command.
  * `status`: e.g., `completed`, `skipped`, `partial`.
  * `logged_at`: timestamp when `did` was invoked.
  * Optional notes (future-friendly).
- Store entries keyed by `name + start_time` to avoid collisions when the same item appears multiple times. Example YAML:
  ```yaml
  entries:
    "Morning Meditation@07:30":
      status: completed
      scheduled_start: "07:30"
      scheduled_end: "07:50"
      actual_start: "07:32"
      actual_end: "07:55"
      logged_at: "2025-11-25T07:56:00"
  ```

`did` command design
--------------------
- Syntax: `did "<name or template>" [start_time:HH:MM] [end_time:HH:MM] [status:completed|skipped|partial] [note:"..."]`.
  * `start_time` / `end_time` default to the scheduled values from `today_schedule.yml`.
  * `status` defaults to `completed`. Other statuses (e.g., `skipped`) allow marking intentional gaps.
- Behavior:
  1. Load today’s schedule and find the block whose name matches the provided string. If multiple blocks share the name, use `start_time` to disambiguate; otherwise, prompt the user or pick the earliest upcoming/past block.
  2. Write/update the entry in the per-day completion file using a composite key (e.g., `name@scheduled_start`).
  3. Include the scheduled start/end for traceability, even if the user supplies actual times.
  4. Optionally, if the command targets another day (e.g., `did "Deep Work" date:2025-11-26`), allow a `date` property to log historical corrections.
- Immediate feedback: echo what was recorded (“Marked Morning Meditation as completed (07:30-07:50).”).

Status derivation rules for display
----------------------------------
- When `today` renders each block, determine its status using:
  1. Completion entries (`entries` map) for that block key:
     * If an entry exists with `status: completed`, label the block “completed” (regardless of the current time).
     * If `status: skipped`, label as “skipped”.
     * If a different status is stored (e.g., `partial`), display that label.
  2. If no completion entry exists:
     * If current time < scheduled start → “upcoming”.
     * If scheduled start ≤ current time < scheduled end → “in progress”.
     * If current time ≥ scheduled end → “missed”.
- Display both the status text and the existing color (time-based). Example: `07:30 - 07:50 Morning Meditation (20m) [completed]`.
- Optionally add icons/emojis (✓, ⏳, ⚠️) for quick recognition, but keep text for accessibility.

Open considerations
-------------------
1. Lookup keys: ensure the composite key scheme handles duplicate names (e.g., multiple “Break” blocks). Might use `item_id` if available.
2. Editing/undo: should there be a `did undo "<name>"` or `clear` command to remove entries?
3. Automatic transitions: should `missed` entries be auto-written when the day ends, or only implied for display?
4. Integration with dashboard: align the CLI completion storage format with the Dashboard’s Today widget so both show consistent statuses.
5. Historical logging: consider moving completion entries into a `history` section to keep the file compact if the user logs many partials.

Next steps (after consensus)
----------------------------
1. Implement the `did` command (new file under `Commands/`) that performs the lookup + writes completions.
2. Update `today` display logic to read the richer completion map and append status labels.
3. Document the new command + status behavior in Docs/README, Docs/agents.md, and the workflow guides.
