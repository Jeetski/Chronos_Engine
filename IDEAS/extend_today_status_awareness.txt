Goal: make `today` (and derived schedulers) status-aware so templates and items adapt to the pilot’s current state without hardcoded status types.

Key concepts
------------
- Status taxonomy is user-defined. The engine must read all status types + their ranked levels from `User/Settings/Status_Settings.yml` and the pilot’s current values from `User/Current_Status.yml`. No hardcoded keys (focus, emotion, etc.).
- Templates/items expose status metadata via a flexible shape. Proposed conventions:
  * Preferred: `status_requirements:<map>` where keys match user-defined status types and values are str or list (e.g., `{ focus: [sharp, normal], emotion: calm }`).
  * Backward-compatible: allow top-level keys matching known status types for users who already tag items that way. Normalize both shapes into a single map.
- Multiple values per status type are allowed. Any match counts as “compatible.” Later we can support min/max semantics (e.g., `focus_min: medium`) if the settings file defines numeric ordering.
- Hierarchy awareness: templates influence the agenda from the top down. Day template selection happens before we descend into routines → subroutines → microroutines → items. If the user tags a day template with `status_requirements.health: sick`, and their current status says `health: sick`, the scheduler should pick that template even if it’s not the default for that weekday.
- Item priority tie-ins: once a template is chosen, the per-item importance calculation should boost items whose status tags match the current state (e.g., meditation marked `focus: absent` floats to the top when the user’s focus is “absent”), unless higher-ranked constraints (deadlines, dependencies) override it.

Template selection flow
-----------------------
1. Enumerate all available templates for the current day. If multiple variants exist (e.g., `Monday.yml`, `Monday_low_focus.yml`), allow them all to compete instead of hardcoding one file path.
2. For each template, parse its status map and compute a compatibility score against `Current_Status.yml`.
   - Score heuristics: +N points per matching status type/value, weighted by the status type’s “Rank” in `Status_Settings.yml`.
   - If a template specifies multiple values for a type, matching any value counts. Templates without tags default to score 0 (so they lose to tagged ones when the user’s state matches).
   - Consider partial matches: if the template lists `energy: [medium, high]` and the user is `energy: high`, give full credit; if they’re `energy: low`, subtract or leave neutral.
3. Pick the highest scoring template. Ties fall back to the existing default behavior (e.g., whichever template matches the weekday basename), ensuring deterministic output.
4. When no template has status tags or `Current_Status.yml` is missing, skip the scoring and behave exactly like the current `today` implementation.

Item importance enhancements
----------------------------
- Extend `calculate_item_importance` to consider status tags in addition to the existing priority/due-date/category logic.
  * If an item specifies `status_requirements` and the pilot’s current status matches, subtract a configurable bonus from its importance score.
  * If the pilot’s status conflicts with the item’s tags (e.g., item requires `focus: sharp`, user is `focus: absent`), either add a penalty (lowering priority) or optionally skip scheduling that item unless it has a hard deadline/dependency.
  * Let users opt in to “inverse” behavior (e.g., `status_preferred_when: { focus: absent }` meaning “do this when focus is absent” vs `status_requires` meaning “only do when focus is sharp”). Clarify naming to avoid confusion.
- The status influence should cascade down the hierarchy:
  * Entire routines/subroutines tagged for specific states can be boosted/penalized as blocks.
  * Leaf items inherit the same logic, so meditation (tagged `focus: absent`) rises in priority when the user’s focus is absent.
- Respect hard constraints: even if meditation gets a strong boost, tasks with strict due dates or dependencies should still block it when necessary. The status bonus simply feeds into the importance score rather than outright reordering everything.

Open questions / decisions
--------------------------
1. Template discovery: do we stick with one file per weekday, or allow suffixes like `Monday__low_focus.yml`? Need a convention (e.g., `Monday.[tag].yml`) so the engine knows which files to consider.
2. Tag semantics: Do we differentiate between “required” vs “ideal” statuses? Example structure:
   ```
   status_requirements:
     energy:
       required: [medium, high]
       preferred: [high]
     focus:
       preferred: [absent]
   ```
   or keep it simple with a flat list and interpret matching as a soft preference.
3. Scoring weights: Should each status type have a configurable weight in `Status_Settings.yml` (already has `Rank`), and should each status level’s “value” be used to grade closeness (e.g., high vs medium vs low)? Need to document the formula so users can predict behavior.
4. Conflicting tags: if a template tags `focus: sharp` and `focus: absent` simultaneously (due to user error), do we treat it as “any focus level works” or warn the user?
5. Opt-out: Should there be a `status_ignore:true` flag on templates/items for users who don’t want status-based adjustments?
6. Manual overrides / macros: when users manually change status mid-day and run `today reschedule`, should the engine re-evaluate template choice? (Probably yes.)
7. Interaction with manual modifications: if a user already applied manual tweaks, rescheduling with a different template may blow them away. Need to remind users or reapply modifications intelligently.
8. Backward compatibility: Most existing templates/items lack status tags. Ensure the default pipeline (without tags) behaves exactly as before.

Implementation outline (future work, once decisions finalized)
-------------------------------------------------------------
1. Extend template loader to gather all candidate files for the day and attach parsed status metadata.
2. Write a scoring helper that compares `Current_Status` vs `status_requirements` using `Status_Settings` for weights/ordering.
3. Inject the template scoring before `build_initial_schedule` runs.
4. Enhance `calculate_item_importance` (and potentially `build_initial_schedule`) to consider status tags at every hierarchy level.
5. Update docs (Docs/README, agents guides) to explain how to tag templates/items and how the scheduler reacts.
