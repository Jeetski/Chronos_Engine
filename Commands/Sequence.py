import os
from datetime import datetime
from typing import List, Optional

from Modules.Sequence import (
    ensure_data_home,
    load_registry,
    update_database_entry,
    describe_registry,
    DEFAULT_DATABASES,
)
from Modules.Sequence.matrix_builder import build_matrix_cache
from Modules.Sequence.core_builder import build_core_db
from Modules.Sequence.memory_builder import build_memory_db
from Modules.Sequence.events_builder import build_events_db
from Modules.Sequence.trends_builder import build_trends_report

SYNC_HANDLERS = {
    "matrix": build_matrix_cache,
    "core": build_core_db,
    "memory": build_memory_db,
    "events": build_events_db,
    "trends": build_trends_report,
}


def _timestamp() -> str:
    return datetime.now().isoformat(timespec="seconds")


def _resolve_targets(args: List[str], properties: dict) -> List[str]:
    tokens = [token.strip().lower() for token in args if token.strip()]
    if not tokens:
        prop_value = properties.get("db") or properties.get("database")
        if isinstance(prop_value, str) and prop_value.strip():
            tokens = [part.strip().lower() for part in prop_value.split(",") if part.strip()]

    known = sorted(DEFAULT_DATABASES.keys())
    if not tokens:
        return known

    resolved: List[str] = []
    for token in tokens:
        if token == "all":
            return known
        if token not in DEFAULT_DATABASES:
            raise ValueError(f"Unknown database key '{token}'. Known keys: {', '.join(known)}")
        resolved.append(token)
    return resolved


def _mark_placeholder_sync(registry: dict, key: str, note: Optional[str] = None) -> None:
    entry = update_database_entry(
        registry,
        key,
        last_attempt=_timestamp(),
        status="pending",
        notes=note or "Scaffold in place. Full sync will be wired in future phases.",
    )
    ensure_data_home()
    path = entry.get("path")
    if path and entry.get("type") == "markdown":
        if not os.path.exists(path):
            with open(path, "w", encoding="utf-8") as fh:
                fh.write(f"# {entry.get('name', 'Chronos Trends')}\n\n")
                fh.write("This digest will be generated by `sequence trends` in a later phase.\n")


def _handle_sync(args: List[str], properties: dict, registry: dict) -> None:
    try:
        keys = _resolve_targets(args, properties)
    except ValueError as exc:
        print(exc)
        return

    executed: List[str] = []
    for key in keys:
        handler = SYNC_HANDLERS.get(key)
        if handler:
            try:
                handler(registry)
                executed.append(key)
            except Exception as exc:  # pragma: no cover - surfaced to CLI
                print(f"Error while syncing '{key}': {exc}")
        else:
            _mark_placeholder_sync(registry, key)
            executed.append(key)

    if executed:
        label = "all datasets" if len(executed) == len(DEFAULT_DATABASES) else ", ".join(executed)
        print(f"Sequence sync executed for {label}.")
    else:
        print("No matching datasets were synced.")


def _handle_status(registry: dict) -> None:
    print("Chronos Sequence Registry")
    print("-------------------------")
    for line in describe_registry(registry):
        print(line)


def _ensure_trends_digest(registry: dict) -> None:
    entry = registry.get("databases", {}).get("trends_digest")
    if not entry:
        entry = update_database_entry(registry, "trends_digest")
    path = entry.get("path")
    ensure_data_home()
    if not path:
        print("Could not determine trends digest path.")
        return
    os.makedirs(os.path.dirname(path), exist_ok=True)
    if not os.path.exists(path):
        with open(path, "w", encoding="utf-8") as fh:
            fh.write("# Chronos Trends Digest\n\n")
            fh.write("This file will summarize behavior trends captured by sequence sync runs.\n")
    update_database_entry(
        registry,
        "trends_digest",
        last_attempt=_timestamp(),
        status="pending",
        notes="Created placeholder digest file.",
    )
    print(f"Ensured trends digest placeholder exists at: {path}")


def run(args, properties):  # noqa: D401 - standard command entrypoint
    """
    Chronos Sequence command scaffolding.
    """
    ensure_data_home()
    registry = load_registry()

    if not args:
        print(get_help_message())
        return

    subcommand = args[0].lower()
    remaining = args[1:]

    if subcommand == "sync":
        _handle_sync(remaining, properties, registry)
    elif subcommand == "status":
        _handle_status(registry)
    elif subcommand == "trends":
        try:
            build_trends_report(registry)
            print(f"Trends digest refreshed at: {_timestamp()}")
            print(f"Path: {os.path.join('User', 'Data', 'trends.md')}")
        except Exception as exc:
            print(f"Unable to refresh trends digest: {exc}")
    else:
        print(f"Unknown subcommand '{subcommand}'.")
        print(get_help_message())


def get_help_message() -> str:
    return """Chronos Sequence

Usage:
  sequence status
      Show the current registry of SQLite mirrors and digests.

  sequence sync [matrix|core|events|memory|trends|trends_digest ...]
      Placeholder sync hook. If no targets are provided it touches every dataset.
      Use space-separated keys (e.g., `sequence sync matrix core`). Properties
      `db`/`database` still work for automation hooks.

  sequence trends
      Refreshes `chronos_trends.db` and rewrites `User/Data/trends.md` with the
      latest completion metrics.
"""
